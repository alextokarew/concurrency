h1. Основные модели параллельного программирования на примере

h1. Содержание
# Введение
## Книга
## Concurrency or Parallelism?
# Threads and Syncronization
## Суть
## Пример
## Достоинства/недостатки
# Functional programming
# Actors
# CSP
# The Lambda Architecture
# Прочее (Data Parallelism и т.п.)
# Выводы

h1. Книга

Данная статья написана по мотивам книги "Seven Concurrency Models In Seven Weeks":http://www.amazon.com/Seven-Concurrency-Models-Weeks-Programmers/dp/1937785653.

__картинка с книгой__

h1. Введение

Параллельное программирование само по себе не является чем-то новым. Однако из-за того, что в последнее десятилетие рост производительности процессоров достигается за счет увеличения числа ядер, его актуальность резко возрасла. Кроме того, все большее внимание уделяется распределенным кластеризованным системам, способным обрабатывать очень большие объемы данных. 

Даже привычные нам системы получают преимущество от использования параллельного программирования. Например, когда вы набираете программный код в IDE, она в фоновом режиме проверяет корректность синтаксиса. Для того, чтобы смотреть видео на YouTube необязательно ждать его полной загрузки. Приложение будет одновременно скачивать недостающие части, и показывать уже загруженные. Отказоустойчивость современных высоконагруженных серверов, таких как Google или Amazon, также достигается при помощи параллельного программирования.

Важность параллельного программирования растет с каждым днем. Рост интереса к таким языкам, как Scala, Go, Erlang, Haskell, Closure не в последнюю очередь связан с их мощной поддержкой параллельного программирования.

h3. Многопоточное и параллельное программирование.

Очень часть параллельное программирование отождествляют с многопоточным программированием. И хотя между ними есть много общего, различия все же есть. Основная задача многопоточного программирования - это обеспечить согласованный доступ нескольких потоков выполнения к некоторому общему ресурсу. Сами же потоки необязательно должны выполняться в одно время. Примером многопоточной задачи являются системы резервирования билетов, где большое количество покупателей работают с единым хранилищем доступных мест.

__тут идет картинка с человеком, одновременно делающим много дел__
__Здесь множество потоков выполнения (дела) пытаются завладеть одним ресурсом (человеком, который их делает)__

Параллельное программирование же имеет дело с распределением выполнения одной задачи на несколько логических потоков. Пример задачи для параллельного программирования - анализ большого объема данных, когда исходный документ разбивается на части, и каждая часть обрабатывается в отдельном потоке (более подробный пример будет рассмотрен ниже).

__тут картинка сборочного цеха на китайском заводе, где куча китайцев заняты производством одних и тех же вещей__

По сути, необходимость в многопоточном программировании возникает при постановке задачи, когда необходимо иметь дело с событиями, возникающими одновременно. В то же время параллельное программирование - это один из способов для решения различных типов задач.

h2. Задача

Модели параллельного программирования мы будем рассматривать на примере. Задача простая: найти 100 самых используемых слов в англоязычной википедии. Для ее решения необходимы следующие шаги:
# Парсинг "XML-дампа страниц":http://dumps.wikimedia.org/enwiki/latest/
# Подсчет количества вхождений каждого слова на каждой из этих страниц

В случае реализации методом обычного последовательного программирования код получится примерно следующий:
<source lang="Java">
  ...
  Map<String, Integer> counts = new HashMap<String, Integer>();
  Iterable<Page> pages = new Pages(100000, "enwiki.xml");
  for(Page page: pages) {
    Iterable<String> words = new Words(page.getText());
    for (String word: words) {
      Integer currentCount = counts.get(word);
      if (currentCount == null)
        counts.put(word, 1);
      else
        counts.put(word, currentCount + 1);
    }
  }
  ...
</source>
Как видим, реализация довольно простая. Однако из-за того, что все инструкции выполняются последовательно в одном потоке выполнения, данное решение нельзя назвать масштабируемым. Основная причина неэффективности данного решения заключается в том, что процесс подсчета начинается только после окончания парсинга всех страниц. Параллельное программирование дает нам возможность организации кода так, что подсчет слов можно будет начать сразу же после того, как будет доступна первая страница.

h2. Многопоточное программирование и синхронизация

Многопоточное программирование является наиболее прямолинейным способом реализации параллельного программирования. Все другие модели параллельного программирования так или иначе сводятся к многопоточному программированию, так как оно наиболее четко отражает все аппаратные процессы. Основным недостатком многопоточного программирования, как и любого другого низкоуровнего программирования, является необходимость для разработчика самостоятельно управлять синхронизацией доступа к общим ресурсам, а также обрабатывать исключительные ситуации и перезапускать потоки.

Понимание многопоточности в любом случае важно, независимо от того, какую модель параллельного программирования вы планируете использовать.

__Пример взаимной блокировки (dining philosophers)__

Решение нашей задачи с применением многопоточного программирования будет выглядеть следующим образом:
<source lang="Java">
  class Parser implements Runnable {
    private BlockingQueue<Page> queue;

    public Parser(BlockingQueue<Page> queue) {
      this.queue = queue;
    }
    
    public void run() {
      try {
        Iterable<Page> pages = new Pages(100000, "enwiki.xml");
        for (Page page: pages)
          queue.put(page);
      } catch (Exception e) { e.printStackTrace(); }
    }
  }

  class Counter implements Runnable {
    private BlockingQueue<Page> queue;
    private Map<String, Integer> counts;
    
    public Counter(BlockingQueue<Page> queue,
                   Map<String, Integer> counts) {
      this.queue = queue;
      this.counts = counts;
    }

    public void run() {
      try {
        while(true) {
          Page page = queue.take();
          if (page.isPoisonPill())
            break;

          Iterable<String> words = new Words(page.getText());
          for (String word: words)
            countWord(word);
        }
      } catch (Exception e) { e.printStackTrace(); }
    }

    private void countWord(String word) {
      Integer currentCount = counts.get(word);
      if (currentCount == null)
        counts.put(word, 1);
      else
        counts.put(word, currentCount + 1);
    }
  }
</source>

Данное решение является примером реализации паттерна Producer-Consumer. В нашем случае класс Parser является Producer-ом, а класс Counter - Consumer-ом. 


{code}

У данного решения есть одно узкое место: мы используем синхронизованное общее хранилище для подсчета. Что если каждый поток будет считать, используя собственное локальное хранилище, а затем мы просто сложим результаты? Это получается классический пример Map-Reduce.

{code}

При рассмотрении следующих моделей параллельного программирования мы также будем использовать эту задачу.

h3. Достоинства и недостатки

Достоинства: многопоточное программирование, из-за своей "близости к железу", при правильном использовании может быть очень эффективно. Оно является основой для всех остальных моделей, рассмотренных ниже.

Недостатки: При многопоточном программировании могут возникнуть две основные проблемы: гонки (race conditions) и взаимные блокировки (deadlocks). Гонки возникают в случае недостатка синхронизации между потоками, взаимные блоки же наоборот, возникают при избытке и неправильном использовани синхронизации. 

Гонки (race conditions) - ситуация, когда два и более потока пытаются одновременно изменить один и тот же ресурс. Для предотвращения гонок необходима синхронизация доступа к ресурсам.

__картинка с примером гонок__

Взаимная блокировка (Deadlock) - ситуация, когда один поток ждет, когда другой поток отпустит блокировку, который в свою очередь ждет, когда первый поток отпустит другую блокировку. Для избежания взаимных блокировок необходимо захватывать ресурсы всегда в строго определенном порядке. Само по себе многопоточное программирование является достаточно сложной, нетривиальной задачей. При многопоточном программировании необходимо правильно управлять синхронизацией, избегая гонок и взаимных блокировок. Кроме того, многопоточное программирование само по себе не поддерживает распараллеливание задач.

h2. Функциональное программирование

h3. Достоинства и недостатки

Программы в функциональном стиле как правило более выразительны