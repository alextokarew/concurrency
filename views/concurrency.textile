h1. Основные модели параллельного программирования

h1. Содержание
# Введение
## Книга
## Concurrency or Parallelism?
# Threads and Syncronization
## Суть
## Пример
## Достоинства/недостатки
# Functional programming
# Actors
# CSP
# The Lambda Architecture
# Прочее (Data Parallelism и т.п.)
# Выводы

h1. Книга

Данная статья написана по мотивам книги "Seven Concurrency Models In Seven Weeks":http://www.amazon.com/Seven-Concurrency-Models-Weeks-Programmers/dp/1937785653.

__картинка с книгой__

h1. Введение

Параллельное программирование само по себе не является чем-то новым. Однако из-за того, что в последнее десятилетие рост производительности процессоров достигается за счет увеличения числа ядер, его актуальность резко возрасла. Кроме того, все большее внимание уделяется распределенным кластеризованным системам, способным обрабатывать очень большие объемы данных. 

Даже привычные нам системы получают преимущество от использования параллельного программирования. Например, когда вы набираете программный код в IDE, она в фоновом режиме проверяет корректность синтаксиса. Для того, чтобы смотреть видео на YouTube необязательно ждать его полной загрузки. Приложение будет одновременно скачивать недостающие части, и показывать уже загруженные. Отказоустойчивость современных высоконагруженных серверов, таких как Google или Amazon, также достигается при помощи параллельного программирования.

Важность параллельного программирования растет с каждым днем. Рост интереса к таким языкам, как Scala, Go, Erlang, Haskell, Closure не в последнюю очередь связан с их мощной поддержкой параллельного программирования.

h2. Многопоточное и параллельное программирование.

Очень часть параллельное программирование отождествляют с многопоточным программированием. И хотя между ними есть много общего, различия все же есть. Основная задача многопоточного программирования - это обеспечить согласованный доступ нескольких потоков выполнения к некоторому общему ресурсу. Сами же потоки необязательно должны выполняться в одно время. Примером многопоточной задачи являются системы резервирования билетов, где большое количество покупателей работают с единым хранилищем доступных мест.

__тут идет картинка с человеком, одновременно делающим много дел__
__Здесь множество потоков выполнения (дела) пытаются завладеть одним ресурсом (человеком, который их делает)__

Параллельное программирование же имеет дело с распределением выполнения одной задачи на несколько логических потоков. Пример задачи для параллельного программирования - анализ большого объема данных, когда исходный документ разбивается на части, и каждая часть обрабатывается в отдельном потоке (более подробный пример будет рассмотрен ниже).

__тут картинка сборочного цеха на китайском заводе, где куча китайцев заняты производством одних и тех же вещей__

По сути, необходимость в многопоточном программировании возникает при постановке задачи, когда необходимо иметь дело с событиями, возникающими одновременно. В то же время параллельное программирование - это один из способов для решения различных типов задач.

h2. Многопоточное программирование и синхронизация

Многопоточное программирование является наиболее прямолинейным способом реализации параллельного программирования. Все другие модели параллельного программирования так или иначе сводятся к многопоточному программированию, так как оно наиболее четко отражает все аппаратные процессы. Основным недостатком многопоточного программирования, как и любого другого низкоуровнего программирования, является необходимость для разработчика самостоятельно управлять синхронизацией доступа к общим ресурсам, а также обрабатывать исключительные ситуации и перезапускать потоки.

Понимание многопоточности в любом случае важно, независимо от того, какую модель параллельного программирования вы планируете использовать.

При многопоточном программировании могут возникнуть две основные проблемы: гонки (race conditions) и взаимные блокировки (deadlocks). Гонки возникают в случае недостатка синхронизации между потоками, взаимные блоки же наоборот, возникают при избытке и неправильном использовани синхронизации. 

Гонки (race conditions) - ситуация, когда два и более потока пытаются одновременно изменить один и тот же ресурс. Для предотвращения гонок необходима синхронизация доступа к ресурсам.

__картинка с примером гонок__

Взаимная блокировка (Deadlock) - ситуация, когда один поток ждет, когда другой поток отпустит блокировку, который в свою очередь ждет, когда первый поток отпустит другую блокировку. Для избежания взаимных блокировок необходимо захватывать ресурсы всегда в строго определенном порядке.

__Пример взаимной блокировки (dining philosophers)__

h3. Пример

В качестве примера рассмотрим задачу по подсчету частоты использования слов на страницах Википедии. Решение состоит из следующих частей: парсинг дампа страниц и подсчет общего числа слов. Рассмотрим последовательное решение данной задачи:

{code}

Как видим, код получился достаточно простым, но неэффективным. Что если после парсинга одной страницы мы сразу же начнем подсчет слов на ней, и одновременно будем парсить следующую? Для этого мы запустим парсинг и подсчет в разных потоках, реализовав таким образом классическую модель Producer-Consumer.

{code}

У данного решения есть одно узкое место: мы используем синхронизованное общее хранилище для подсчета. Что если каждый поток будет считать, используя собственное локальное хранилище, а затем мы просто сложим результаты? Это получается классический пример Map-Reduce.

{code}

При рассмотрении следующих моделей параллельного программирования мы также будем использовать эту задачу.

h3. Достоинства и недостатки

Достоинства: многопоточное программирование, из-за своей "близости к железу", при правильном использовании может быть очень эффективно. Оно является основой для всех остальных моделей, рассмотренных ниже.

Недостатки: Само по себе многопоточное программирование является достаточно сложной, нетривиальной задачей. При многопоточном программировании необходимо правильно управлять синхронизацией, избегая гонок и взаимных блокировок. Кроме того, многопоточное программирование само по себе не поддерживает распараллеливание задач.